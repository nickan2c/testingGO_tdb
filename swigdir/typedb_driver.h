/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * This enum is used to specify the type of the session.
 *
 * # Examples
 *
 * ```rust
 * Session::new(database, SessionType::Schema).await
 * ```
 */
typedef enum SessionType {
  Data = 0,
  Schema = 1,
} SessionType;

/**
 * This enum is used to specify the type of transaction.
 *
 * # Examples
 *
 * ```rust
 * session.transaction(TransactionType::READ)
 * ```
 */
typedef enum TransactionType {
  Read = 0,
  Write = 1,
} TransactionType;

/**
 * Used for specifying whether we need explicit or transitive subtyping, instances, etc.
 *
 * # Examples
 *
 * ```rust
 * entity_type.get_subtypes(transaction, Transitivity::Transitive);
 * relation_type.get_instances(transaction, Transitivity::Explicit);
 * ```
 */
typedef enum Transitivity {
  Explicit,
  Transitive,
} Transitivity;

/**
 * Represents the type of primitive value is held by a Value or Attribute.
 */
typedef enum ValueType {
  Object,
  Boolean,
  Long,
  Double,
  String,
  DateTime,
} ValueType;

/**
 * Annotations are used to specify extra schema constraints.
 */
typedef struct Annotation Annotation;

/**
 * Promise object representing the result of an asynchronous operation.
 * Use \ref bool_promise_resolve(BoolPromise*) to wait for and retrieve the resulting boolean value.
 */
typedef struct BoolPromise BoolPromise;

/**
 * The fundamental TypeQL object. A Concept is either a Type, Thing, or Value.
 * To use subtype specific methods, the Concept must be of the expected subtype.
 */
typedef struct Concept Concept;

/**
 * Iterator over the <code>Concepts</code>s returned by an API method or query.
 */
typedef struct ConceptIterator ConceptIterator;

/**
 * Contains a mapping of variables to concepts.
 */
typedef struct ConceptMap ConceptMap;

/**
 * Contains an element of the TypeQL Get Group query result.
 */
typedef struct ConceptMapGroup ConceptMapGroup;

/**
 * Iterator over the <code>ConceptMapGroup</code>s in the result of the TypeQL Get Group query.
 */
typedef struct ConceptMapGroupIterator ConceptMapGroupIterator;

/**
 * Iterator over the <code>ConceptMap</code>s in the result of a TypeQL Get query.
 */
typedef struct ConceptMapIterator ConceptMapIterator;

/**
 * Promise object representing the result of an asynchronous operation.
 * Use \ref concept_promise_resolve(ConceptPromise*) to wait for and retrieve the resulting boolean value.
 */
typedef struct ConceptPromise ConceptPromise;

/**
 * A connection to a TypeDB server which serves as the starting point for all interaction.
 */
typedef struct Connection Connection;

/**
 * User credentials and TLS encryption settings for connecting to TypeDB Cloud.
 */
typedef struct Credential Credential;

/**
 * A TypeDB database
 */
typedef struct Database Database;

/**
 * An <code>Iterator</code> over databases present on the TypeDB server
 */
typedef struct DatabaseIterator DatabaseIterator;

/**
 * Provides access to all database management methods.
 */
typedef struct DatabaseManager DatabaseManager;

/**
 * Represents errors encountered during operation.
 */
typedef struct Error Error;

/**
 * Contains an explainable object.
 */
typedef struct Explainable Explainable;

/**
 * Contains explainable objects.
 */
typedef struct Explainables Explainables;

/**
 * An explanation of which rule was used for inferring the explained concept,
 * the condition of the rule, the conclusion of the rule,
 * and the mapping of variables between the query and the rule’s conclusion.
 */
typedef struct Explanation Explanation;

/**
 * Iterator over the <code>Explanation</code>s in the result of the explain query.
 */
typedef struct ExplanationIterator ExplanationIterator;

/**
 * TypeDB session and transaction options.
 * `TypeDBOptions` object can be used to override the default server behaviour.
 * Options are specified using properties assignment.
 *
 * # Examples
 *
 * ```rust
 * let options = Options::new().infer(true).explain(true);
 * ```
 */
typedef struct Options Options;

/**
 * The metadata and state of an individual raft replica of a database.
 */
typedef struct ReplicaInfo ReplicaInfo;

/**
 * Iterator over the <code>ReplicaInfo</code> corresponding to each replica of a TypeDB cloud database.
 */
typedef struct ReplicaInfoIterator ReplicaInfoIterator;

/**
 * A pair representing the concept and the role it plays in a relation.
 * The result of \ref relation_get_role_players(Transaction*, Concept*)
 */
typedef struct RolePlayer RolePlayer;

/**
 * An iterator over <code>RolePlayer</code> pairs returned by \ref relation_get_role_players(Transaction*, Concept*)
 */
typedef struct RolePlayerIterator RolePlayerIterator;

/**
 * Rules are a part of schema and define embedded logic.
 * The reasoning engine uses rules as a set of logic to infer new data.
 * A rule consists of a condition and a conclusion, and is uniquely identified by a label.
 */
typedef struct Rule Rule;

/**
 * An iterator over <code>Rule</code>s in the database
 */
typedef struct RuleIterator RuleIterator;

/**
 * Promise object representing the result of an asynchronous operation.
 * Use \ref rule_promise_resolve(RulePromise*) to wait for and retrieve the resulting <code>Rule</code>.
 */
typedef struct RulePromise RulePromise;

/**
 * Represents invalid schema constructs discovered during schema validation.
 */
typedef struct SchemaException SchemaException;

/**
 * Iterator over the <code>SchemaException</code>s in the result of \ref concepts_get_schema_exceptions(Transaction*).
 */
typedef struct SchemaExceptionIterator SchemaExceptionIterator;

/**
 * A session with a TypeDB database.
 */
typedef struct Session Session;

/**
 * Iterator over the strings in the result of a request or a TypeQL Fetch query.
 */
typedef struct StringIterator StringIterator;

/**
 * Iterator over the <code>StringPair</code>s representing explainable owner-attribute variable pairs
 */
typedef struct StringPairIterator StringPairIterator;

/**
 * Promise object representing the result of an asynchronous operation.
 * Use \ref string_promise_resolve(StringPromise*) to wait for and retrieve the resulting string.
 */
typedef struct StringPromise StringPromise;

/**
 * A transaction with a TypeDB database.
 */
typedef struct Transaction Transaction;

/**
 * User information
 */
typedef struct User User;

/**
 * Iterator over a set of <code>User</code>s
 */
typedef struct UserIterator UserIterator;

/**
 * Provides access to all user management methods.
 */
typedef struct UserManager UserManager;

/**
 * Contains an element of a TypeQL Get Group Aggregate query result.
 */
typedef struct ValueGroup ValueGroup;

/**
 * Iterator over the <code>ValueGroup</code>s in the result of the Get Group Aggregate query.
 */
typedef struct ValueGroupIterator ValueGroupIterator;

/**
 * Promise object representing the result of an asynchronous operation.
 * A VoidPromise does not return a value, but must be resolved using \ref void_promise_resolve(VoidPromise*)
 * to ensure the operation has completed, or for a failed operation to set the error.
 */
typedef struct VoidPromise VoidPromise;

/**
 * A <code>StringPair</code> used to represent the pair of variables involved in an ownership.
 * <code>_0</code> and <code>_1</code> are the owner and attribute variables respectively.
 */
typedef struct StringPair {
  char *_0;
  char *_1;
} StringPair;

/**
 * Frees the native rust <code>ConceptMap</code> object
 */
void concept_map_drop(struct ConceptMap *concept_map);

/**
 * Produces an <code>Iterator</code> over all variables in this <code>ConceptMap</code>.
 */
struct StringIterator *concept_map_get_variables(const struct ConceptMap *concept_map);

/**
 * Produces an <code>Iterator</code> over all <code>Concepts</code> in this <code>ConceptMap</code>.
 */
struct ConceptIterator *concept_map_get_values(const struct ConceptMap *concept_map);

/**
 * Retrieves a concept for a given variable name.
 *
 */
struct Concept *concept_map_get(const struct ConceptMap *concept_map, const char *var);

/**
 * Gets the <code>Explainables</code> object for this <code>ConceptMap</code>, exposing
 * which of the concepts in this <code>ConceptMap</code> are explainable.
 */
struct Explainables *concept_map_get_explainables(const struct ConceptMap *concept_map);

/**
 * Checks whether the provided <code>ConceptMap</code> objects are equal
 */
bool concept_map_equals(const struct ConceptMap *lhs, const struct ConceptMap *rhs);

/**
 * A string representation of this ConceptMap.
 */
char *concept_map_to_string(const struct ConceptMap *concept_map);

/**
 * Frees the native rust <code>Explainables</code> object
 */
void explainables_drop(struct Explainables *explainables);

/**
 * Checks whether the provided <code>Explainables</code> objects are equal
 */
bool explainables_equals(const struct Explainables *lhs, const struct Explainables *rhs);

/**
 * A string representation of this <code>Explainables</code> object
 */
char *explainables_to_string(const struct Explainables *explainables);

/**
 * Retrieves the explainable relation with the given variable name.
 */
struct Explainable *explainables_get_relation(const struct Explainables *explainables,
                                              const char *var);

/**
 * Retrieves the explainable attribute with the given variable name.
 */
struct Explainable *explainables_get_attribute(const struct Explainables *explainables,
                                               const char *var);

/**
 * Retrieves the explainable attribute ownership with the pair of (owner, attribute) variable names.
 */
struct Explainable *explainables_get_ownership(const struct Explainables *explainables,
                                               const char *owner,
                                               const char *attribute);

/**
 * Retrieves all variables corresponding to this <code>ConceptMap</code>’s explainable relations.
 */
struct StringIterator *explainables_get_relations_keys(const struct Explainables *explainables);

/**
 * Retrieves all variables corresponding to this <code>ConceptMap</code>’s explainable attributes.
 */
struct StringIterator *explainables_get_attributes_keys(const struct Explainables *explainables);

/**
 * Retrieves all variables corresponding to this <code>ConceptMap</code>’s explainable ownerships.
 */
struct StringPairIterator *explainables_get_ownerships_keys(const struct Explainables *explainables);

/**
 * Frees the native rust <code>Explainable</code> object
 */
void explainable_drop(struct Explainable *explainable);

/**
 * Retrieves the unique ID that identifies this <code>Explainable</code>.
 */
int64_t explainable_get_id(const struct Explainable *explainable);

/**
 * Retrieves the subquery of the original query that is actually being explained.
 */
char *explainable_get_conjunction(const struct Explainable *explainable);

/**
 * Frees the native rust <code>Explanation</code> object
 */
void explanation_drop(struct Explanation *explanation);

/**
 * Checks whether the provided <code>Explanation</code> objects are equal
 */
bool explanation_equals(const struct Explanation *lhs, const struct Explanation *rhs);

/**
 * A string representation of this <code>Explanation</code> object
 */
char *explanation_to_string(const struct Explanation *explanation);

/**
 * Retrieves the Rule for this Explanation.
 */
struct Rule *explanation_get_rule(const struct Explanation *explanation);

/**
 * Retrieves the Conclusion for this Explanation.
 */
struct ConceptMap *explanation_get_conclusion(const struct Explanation *explanation);

/**
 * Retrieves the Condition for this Explanation.
 */
struct ConceptMap *explanation_get_condition(const struct Explanation *explanation);

/**
 * Retrieves the query variables for this <code>Explanation</code>.
 */
struct StringIterator *explanation_get_mapped_variables(const struct Explanation *explanation);

/**
 * Retrieves the rule variables corresponding to the query variable var for this <code>Explanation</code>.
 */
struct StringIterator *explanation_get_mapping(const struct Explanation *explanation,
                                               const char *var);

/**
 * Frees the native rust <code>ConceptMapGroup</code> object
 */
void concept_map_group_drop(struct ConceptMapGroup *concept_map_group);

/**
 * Retrieves the concept that is the group owner.
 */
struct Concept *concept_map_group_get_owner(const struct ConceptMapGroup *concept_map_group);

/**
 * Retrieves the <code>ConceptMap</code>s of the group.
 */
struct ConceptMapIterator *concept_map_group_get_concept_maps(const struct ConceptMapGroup *concept_map_group);

/**
 * A string representation of this <code>ConceptMapGroup</code> object
 */
char *concept_map_group_to_string(const struct ConceptMapGroup *concept_map_group);

/**
 * Checks whether the provided <code>ConceptMapGroup</code> objects are equal
 */
bool concept_map_group_equals(const struct ConceptMapGroup *lhs, const struct ConceptMapGroup *rhs);

/**
 * Frees the native rust <code>ValueGroup</code> object
 */
void value_group_drop(struct ValueGroup *value_group);

/**
 * A string representation of this <code>ValueGroup</code> object
 */
char *value_group_to_string(const struct ValueGroup *value_group);

/**
 * Checks whether the provided <code>ValueGroup</code> objects are equal
 */
bool value_group_equals(const struct ValueGroup *lhs, const struct ValueGroup *rhs);

/**
 * Retrieves the concept that is the group owner.
 */
struct Concept *value_group_get_owner(struct ValueGroup *value_group);

/**
 * Retrieves the <code>Value</code> answer of the group.
 */
struct Concept *value_group_get_value(struct ValueGroup *value_group);

/**
 * Forwards the <code>StringIterator</code> and returns the next string if it exists,
 * or null if there are no more elements.
 */
char *string_iterator_next(struct StringIterator *it);

/**
 * Frees the native rust <code>StringIterator</code> object
 */
void string_iterator_drop(struct StringIterator *it);

/**
 * Frees the native rust <code>StringPair</code> object
 */
void string_pair_drop(struct StringPair *string_pair);

/**
 * Forwards the <code>StringIterator</code> and returns the next <code>StringPair</code> if it exists,
 * or null if there are no more elements.
 */
struct StringPair *string_pair_iterator_next(struct StringPairIterator *it);

/**
 * Frees the native rust <code>StringPairIterator</code> object
 */
void string_pair_iterator_drop(struct StringPairIterator *it);

/**
 * Waits for and returns the result of the operation represented by the <code>ConceptPromise</code> object.
 * In case the operation failed, the error flag will only be set when the promise is resolved.
 * The native promise object is freed when it is resolved.
 */
struct Concept *concept_promise_resolve(struct ConceptPromise *promise);

/**
 * Forwards the <code>ConceptIterator</code> and returns the next <code>Concept</code> if it exists,
 * or null if there are no more elements.
 */
struct Concept *concept_iterator_next(struct ConceptIterator *it);

/**
 * Frees the native rust <code>ConceptIterator</code> object
 */
void concept_iterator_drop(struct ConceptIterator *it);

/**
 * Forwards the <code>RolePlayerIterator</code> and returns the next <code>RolePlayer</code> if it exists,
 * or null if there are no more elements.
 */
struct RolePlayer *role_player_iterator_next(struct RolePlayerIterator *it);

/**
 * Frees the native rust <code>RolePlayerIterator</code> object
 */
void role_player_iterator_drop(struct RolePlayerIterator *it);

/**
 * Frees the native rust <code>RolePlayer</code> object
 */
void role_player_drop(struct RolePlayer *role_player);

/**
 * Returns the role-type played by the <code>RolePlayer</code>
 */
struct Concept *role_player_get_role_type(const struct RolePlayer *role_player);

/**
 * Returns the <code>Concept</code> which plays the role in the <code>RolePlayer</code>
 */
struct Concept *role_player_get_player(const struct RolePlayer *role_player);

/**
 * Creates a new ``Value`` object of the specified boolean value.
 */
struct Concept *value_new_boolean(bool bool_);

/**
 * Creates a new ``Value`` object of the specified long value.
 */
struct Concept *value_new_long(int64_t long_);

/**
 * Creates a new ``Value`` object of the specified double value.
 */
struct Concept *value_new_double(double double_);

/**
 * Creates a new ``Value`` object of the specified string value.
 */
struct Concept *value_new_string(const char *string);

/**
 * Creates a new ``Value`` object of the specified datetime value.
 */
struct Concept *value_new_date_time_from_millis(int64_t millis);

/**
 * Returns <code>true</code> if the value which this ``Value`` concept holds is of type <code>boolean</code>.
 * Otherwise, returns <code>false</code>.
 */
bool value_is_boolean(const struct Concept *value);

/**
 * Returns <code>true</code> if the value which this ``Value`` concept holds is of type <code>long</code>.
 * Otherwise, returns <code>false</code>.
 */
bool value_is_long(const struct Concept *value);

/**
 * Returns <code>true</code> if the value which this ``Value`` concept holds is of type <code>double</code>.
 * Otherwise, returns <code>false</code>.
 */
bool value_is_double(const struct Concept *value);

/**
 * Returns <code>true</code> if the value which this ``Value`` concept holds is of type <code>string</code>.
 * Otherwise, returns <code>false</code>.
 */
bool value_is_string(const struct Concept *value);

/**
 * Returns <code>true</code> if the value which this ``Value`` concept holds is of type <code>datetime</code>.
 * Otherwise, returns <code>false</code>.
 */
bool value_is_date_time(const struct Concept *value);

/**
 * Returns a <code>boolean</code> value of this value concept.
 * If the value has another type, the error is set.
 */
bool value_get_boolean(const struct Concept *value);

/**
 * Returns the <code>long</code> value of this value concept.
 * If the value has another type, the error is set.
 */
int64_t value_get_long(const struct Concept *value);

/**
 * Returns the <code>double</code> value of this value concept.
 * If the value has another type, the error is set.
 */
double value_get_double(const struct Concept *value);

/**
 * Returns the <code>string</code> value of this value concept.
 * If the value has another type, the error is set.
 */
char *value_get_string(const struct Concept *value);

/**
 * Returns the value of this datetime value concept as milliseconds since the start of the UNIX epoch.
 * If the value has another type, the error is set.
 */
int64_t value_get_date_time_as_millis(const struct Concept *value);

/**
 * Produces a ``@key`` annotation.
 */
struct Annotation *annotation_new_key(void);

/**
 * Produces a ``@unique`` annotation.
 */
struct Annotation *annotation_new_unique(void);

/**
 * Frees the native rust <code>Annotation</code> object
 */
void annotation_drop(struct Annotation *annotation);

/**
 * A string representation of this <code>Annotation</code> object
 */
char *annotation_to_string(const struct Annotation *annotation);

/**
 * Checks whether the provided <code>Annotation</code> objects are equal
 */
bool annotation_equals(const struct Annotation *lhs, const struct Annotation *rhs);

/**
 * Checks whether the provided <code>Annotation</code> is ``@key``
 */
bool annotation_is_key(const struct Annotation *annotation);

/**
 * Checks whether the provided <code>Annotation</code> is ``@unique``
 */
bool annotation_is_unique(const struct Annotation *annotation);

/**
 * Checks whether the provided <code>Concept</code> objects are equal
 */
bool concept_equals(const struct Concept *lhs, const struct Concept *rhs);

/**
 * Frees the native rust <code>Concept</code> object
 */
void concept_drop(struct Concept *concept);

/**
 * Checks if the concept is an ``Entity``.
 */
bool concept_is_entity(const struct Concept *concept);

/**
 * Checks if the concept is a ``Relation``.
 */
bool concept_is_relation(const struct Concept *concept);

/**
 * Checks if the concept is an ``Attribute``.
 */
bool concept_is_attribute(const struct Concept *concept);

/**
 * Checks if the concept is a ``Value``.
 */
bool concept_is_value(const struct Concept *concept);

/**
 * Checks if the concept is the root ``thing`` type.
 */
bool concept_is_root_thing_type(const struct Concept *concept);

/**
 * Checks if the concept is an ``EntityType``.
 */
bool concept_is_entity_type(const struct Concept *concept);

/**
 * Checks if the concept is a ``RelationType``.
 */
bool concept_is_relation_type(const struct Concept *concept);

/**
 * Checks if the concept is an ``AttributeType``.
 */
bool concept_is_attribute_type(const struct Concept *concept);

/**
 * Checks if the concept is a ``RoleType``.
 */
bool concept_is_role_type(const struct Concept *concept);

/**
 * A string representation of this <code>Concept</code> object
 */
char *concept_to_string(const struct Concept *concept);

/**
 * Retrieves the root ``EntityType``, “entity”.
 */
struct Concept *concepts_get_root_entity_type(void);

/**
 * Retrieves the root ``RelationType``, “relation”.
 */
struct Concept *concepts_get_root_relation_type(void);

/**
 * Retrieves the root ``AttributeType``, “attribute”.
 */
struct Concept *concepts_get_root_attribute_type(void);

/**
 * Retrieves an <code>EntityType</code> by its label.
 */
struct ConceptPromise *concepts_get_entity_type(const struct Transaction *transaction,
                                                const char *label);

/**
 * Retrieves a <code>RelationType</code> by its label.
 */
struct ConceptPromise *concepts_get_relation_type(const struct Transaction *transaction,
                                                  const char *label);

/**
 * Retrieves an <code>AttributeType</code> by its label.
 */
struct ConceptPromise *concepts_get_attribute_type(const struct Transaction *transaction,
                                                   const char *label);

/**
 * Creates a new <code>EntityType</code> if none exists with the given label,
 *  otherwise retrieves the existing one.
 */
struct ConceptPromise *concepts_put_entity_type(const struct Transaction *transaction,
                                                const char *label);

/**
 * Creates a new <code>RelationType</code> if none exists with the given label,
 *  otherwise retrieves the existing one.
 */
struct ConceptPromise *concepts_put_relation_type(const struct Transaction *transaction,
                                                  const char *label);

/**
 * Creates a new <code>AttributeType</code> if none exists with the given label,
 *  otherwise retrieves the existing one.
 */
struct ConceptPromise *concepts_put_attribute_type(const struct Transaction *transaction,
                                                   const char *label,
                                                   enum ValueType value_type);

/**
 * Retrieves an ``Entity`` instance by its iid.
 */
struct ConceptPromise *concepts_get_entity(const struct Transaction *transaction, const char *iid);

/**
 * Retrieves a ``relation`` instance by its iid.
 */
struct ConceptPromise *concepts_get_relation(const struct Transaction *transaction,
                                             const char *iid);

/**
 * Retrieves an ``Attribute`` instance by its iid.
 */
struct ConceptPromise *concepts_get_attribute(const struct Transaction *transaction,
                                              const char *iid);

/**
 * Forwards the <code>SchemaExceptionIterator</code> and returns the next <code>SchemaException</code> if it exists,
 * or null if there are no more elements.
 */
struct SchemaException *schema_exception_iterator_next(struct SchemaExceptionIterator *it);

/**
 * Frees the native rust <code>SchemaExceptionIterator</code> object
 */
void schema_exception_iterator_drop(struct SchemaExceptionIterator *it);

/**
 * Frees the native rust <code>SchemaException</code> object
 */
void schema_exception_drop(struct SchemaException *schema_exception);

/**
 * Returns the error code of the <code>SchemaException</code> object
 */
char *schema_exception_code(const struct SchemaException *schema_exception);

/**
 * Returns the error message of the <code>SchemaException</code> object
 */
char *schema_exception_message(const struct SchemaException *schema_exception);

/**
 * Retrieves a list of all schema exceptions for the current transaction.
 */
struct SchemaExceptionIterator *concepts_get_schema_exceptions(const struct Transaction *transaction);

/**
 * Retrieves the unique id of the ``Thing``.
 */
char *thing_get_iid(struct Concept *thing);

/**
 * Checks if this ``Thing`` is inferred by a [Reasoning Rule].
 */
bool thing_get_is_inferred(struct Concept *thing);

/**
 * Retrieves the type which this ``Entity`` belongs to.
 */
struct Concept *entity_get_type(const struct Concept *entity);

/**
 * Retrieves the type which this ``Relation`` belongs to.
 */
struct Concept *relation_get_type(const struct Concept *relation);

/**
 * Retrieves the type which this ``Attribute`` belongs to.
 */
struct Concept *attribute_get_type(const struct Concept *attribute);

/**
 * Retrieves the type which this ``Relation`` belongs to.
 */
struct Concept *attribute_get_value(const struct Concept *attribute);

/**
 * Deletes this ``Thing``.
 */
struct VoidPromise *thing_delete(struct Transaction *transaction, struct Concept *thing);

/**
 * Checks if this ``Thing`` is deleted.
 */
struct BoolPromise *thing_is_deleted(struct Transaction *transaction, const struct Concept *thing);

/**
 * Retrieves the ``Attribute``s that this ``Thing`` owns, optionally filtered by ``AttributeType``s.
 *
 * @param transaction The current transaction
 * @param thing The thing to get owned attributes of
 * @param attribute_types a null-terminated array holding the attribute-types to include
 * @param annotations a null-terminated array of annotations - If non-empty, Only retrieves attributes with all given <code>Annotation</code>s
 */
struct ConceptIterator *thing_get_has(struct Transaction *transaction,
                                      const struct Concept *thing,
                                      const struct Concept *const *attribute_types,
                                      const struct Annotation *const *annotations);

/**
 * Assigns an ``Attribute`` to be owned by this ``Thing``.
 */
struct VoidPromise *thing_set_has(struct Transaction *transaction,
                                  struct Concept *thing,
                                  const struct Concept *attribute);

/**
 * Unassigns an ``Attribute`` from this ``Thing``.
 */
struct VoidPromise *thing_unset_has(struct Transaction *transaction,
                                    struct Concept *thing,
                                    const struct Concept *attribute);

/**
 * Retrieves all the ``Relations`` which this ``Thing`` plays a role in,
 * optionally filtered by one or more given roles.
 *
 * @param role_types: a null-terminated array of ``RoleType``s to include.
 */
struct ConceptIterator *thing_get_relations(struct Transaction *transaction,
                                            const struct Concept *thing,
                                            const struct Concept *const *role_types);

/**
 * Retrieves the roles that this ``Thing`` is currently playing.
 */
struct ConceptIterator *thing_get_playing(struct Transaction *transaction,
                                          const struct Concept *thing);

/**
 * Adds a new role player to play the given role in this ``Relation``.
 */
struct VoidPromise *relation_add_role_player(struct Transaction *transaction,
                                             struct Concept *relation,
                                             const struct Concept *role_type,
                                             const struct Concept *player);

/**
 * Removes the association of the given instance that plays the given role in this ``Relation``.
 */
struct VoidPromise *relation_remove_role_player(struct Transaction *transaction,
                                                struct Concept *relation,
                                                const struct Concept *role_type,
                                                const struct Concept *player);

/**
 * Retrieves all role players of this ``Relation``, optionally filtered by given role types.
 *
 * @param role_types: a null-terminated array of ``RoleType``s to include.
 */
struct ConceptIterator *relation_get_players_by_role_type(struct Transaction *transaction,
                                                          const struct Concept *relation,
                                                          const struct Concept *const *role_types);

/**
 * Retrieves all instance involved in the ``Relation``, each paired with the role it plays.
 */
struct RolePlayerIterator *relation_get_role_players(struct Transaction *transaction,
                                                     const struct Concept *relation);

/**
 * Retrieves all role types currently played in this ``Relation``.
 */
struct ConceptIterator *relation_get_relating(struct Transaction *transaction,
                                              const struct Concept *relation);

/**
 * Retrieves the instances that own this ``Attribute``.
 */
struct ConceptIterator *attribute_get_owners(struct Transaction *transaction,
                                             const struct Concept *attribute,
                                             const struct Concept *thing_type);

/**
 * Checks if this type is a root type (""entity"", ""relation"", ""attribute"")
 */
bool thing_type_is_root(const struct Concept *thing_type);

/**
 * Checks if this thing type is prevented from having data instances (i.e., abstract).
 */
bool thing_type_is_abstract(const struct Concept *thing_type);

/**
 * Retrieves the unique label of the thing type.
 */
char *thing_type_get_label(const struct Concept *thing_type);

/**
 * Checks if the thing type has been deleted
 */
struct BoolPromise *thing_type_is_deleted(const struct Transaction *transaction,
                                          const struct Concept *thing_type);

/**
 * Deletes this thing type from the database.
 */
struct VoidPromise *thing_type_delete(const struct Transaction *transaction,
                                      struct Concept *thing_type);

/**
 * Renames the label of the type. The new label must remain unique.
 */
struct VoidPromise *thing_type_set_label(const struct Transaction *transaction,
                                         struct Concept *thing_type,
                                         const char *new_label);

/**
 * Set a <code>ThingType</code> to be abstract, meaning it cannot have instances.
 */
struct VoidPromise *thing_type_set_abstract(const struct Transaction *transaction,
                                            struct Concept *thing_type);

/**
 * Set a <code>ThingType</code> to be non-abstract, meaning it can have instances.
 */
struct VoidPromise *thing_type_unset_abstract(const struct Transaction *transaction,
                                              struct Concept *thing_type);

/**
 * Retrieves <code>AttributeType</code> that the instances of this
 * <code>ThingType</code> are allowed to own directly or via inheritance.
 * Specify <code>Explicit</code> to only include directly owned types,
 * or <code>Transitive</code> to include inherited
 *
 * @param annotations a null-terminated array of <code>Annotation</code>s -
 *                    If non-empty, Only retrieves attribute types owned with all specified annotations.
 */
struct ConceptIterator *thing_type_get_owns(const struct Transaction *transaction,
                                            const struct Concept *thing_type,
                                            const enum ValueType *value_type,
                                            enum Transitivity transitivity,
                                            const struct Annotation *const *annotations);

/**
 * Retrieves the <code>AttributeType</code>, ownership of which is overridden
 *  for this <code>ThingType</code> by the specified <code>AttributeType</code>.
 */
struct ConceptPromise *thing_type_get_owns_overridden(const struct Transaction *transaction,
                                                      const struct Concept *thing_type,
                                                      const struct Concept *overridden_attribute_type);

/**
 * Allows the instances of this <code>ThingType</code> to own the given <code>AttributeType</code>.
 *  Optionally, overriding a previously declared ownership.
 *  With the specified annotations to the ownership.
 *
 * @param transaction The current transaction
 * @param thing_type The thing type which is to own the specified attribute
 * @param attribute_type The attribute type which is to be owned by the specified thing type
 * @param overridden_attribute_type Optional, The attribute whose ownership must be overridden
 * @param annotations A null-terminated array of <code>Annotation</code>s to be added to the ownership
 */
struct VoidPromise *thing_type_set_owns(const struct Transaction *transaction,
                                        struct Concept *thing_type,
                                        const struct Concept *attribute_type,
                                        const struct Concept *overridden_attribute_type,
                                        const struct Annotation *const *annotations);

/**
 * Disallows the instances of this <code>ThingType</code> from owning the given <code>AttributeType</code>.
 */
struct VoidPromise *thing_type_unset_owns(const struct Transaction *transaction,
                                          struct Concept *thing_type,
                                          const struct Concept *attribute_type);

/**
 * Retrieves all direct and inherited (or direct only) roles that are allowed
 * to be played by the instances of this <code>ThingType</code>.
 * Specify <code>Transitive</code> for direct and inherited roles,
 * Or <code>Explicit</code> for directly played roles only.
 */
struct ConceptIterator *thing_type_get_plays(const struct Transaction *transaction,
                                             const struct Concept *thing_type,
                                             enum Transitivity transitivity);

/**
 * Retrieves the <code>RoleType</code> that is overridden by the given ``RoleType`` for this <code>ThingType</code>.
 */
struct ConceptPromise *thing_type_get_plays_overridden(const struct Transaction *transaction,
                                                       const struct Concept *thing_type,
                                                       const struct Concept *overridden_role_type);

/**
 * Allows the instances of this <code>ThingType</code> to play the given role.
 * Optionally, overriding the existing ability to play a role.
 */
struct VoidPromise *thing_type_set_plays(struct Transaction *transaction,
                                         struct Concept *thing_type,
                                         const struct Concept *role_type,
                                         const struct Concept *overridden_role_type);

/**
 * Disallows the instances of this <code>ThingType</code> from playing the given role.
 */
struct VoidPromise *thing_type_unset_plays(const struct Transaction *transaction,
                                           struct Concept *thing_type,
                                           const struct Concept *role_type);

/**
 * Produces a TypeQL pattern for creating this <code>ThingType</code> in a <code>define</code> query.
 */
struct StringPromise *thing_type_get_syntax(const struct Transaction *transaction,
                                            const struct Concept *thing_type);

/**
 * Creates and returns a new instance of this <code>EntityType</code>.
 */
struct ConceptPromise *entity_type_create(struct Transaction *transaction,
                                          const struct Concept *entity_type);

/**
 * Retrieves the most immediate supertype of the given ``EntityType``.
 */
struct ConceptPromise *entity_type_get_supertype(struct Transaction *transaction,
                                                 const struct Concept *entity_type);

/**
 * Sets the supplied <code>EntityType</code> as the supertype of the current <code>EntityType</code>.
 */
struct VoidPromise *entity_type_set_supertype(struct Transaction *transaction,
                                              struct Concept *entity_type,
                                              const struct Concept *supertype);

/**
 * Retrieves all supertypes of the given EntityType.
 */
struct ConceptIterator *entity_type_get_supertypes(struct Transaction *transaction,
                                                   const struct Concept *entity_type);

/**
 * Retrieves all direct and indirect (or direct only) subtypes of the given EntityType.
 * Specify <code>Transitive</code> for direct and indirect subtypes,
 * Or <code>Explicit</code> for directly subtypes only.
 */
struct ConceptIterator *entity_type_get_subtypes(struct Transaction *transaction,
                                                 const struct Concept *entity_type,
                                                 enum Transitivity transitivity);

/**
 * Retrieves all <code>Entity</code> objects that are instances of this <code>EntityType</code> or its subtypes.
 * Specify <code>Transitive</code> for instances of this EntityType and subtypes,
 * Or <code>Explicit</code> of this EntityType only
 */
struct ConceptIterator *entity_type_get_instances(struct Transaction *transaction,
                                                  const struct Concept *entity_type,
                                                  enum Transitivity transitivity);

/**
 * Creates and returns a new instance of this <code>RelationType</code>.
 */
struct ConceptPromise *relation_type_create(struct Transaction *transaction,
                                            const struct Concept *relation_type);

/**
 * Retrieves the most immediate supertype of the given ``RelationType``.
 */
struct ConceptPromise *relation_type_get_supertype(struct Transaction *transaction,
                                                   const struct Concept *relation_type);

/**
 * Sets the supplied <code>RelationType</code> as the supertype of the current <code>RelationType</code>.
 */
struct VoidPromise *relation_type_set_supertype(struct Transaction *transaction,
                                                struct Concept *relation_type,
                                                const struct Concept *supertype);

/**
 * Retrieves all supertypes of the given RelationType.
 */
struct ConceptIterator *relation_type_get_supertypes(struct Transaction *transaction,
                                                     const struct Concept *relation_type);

/**
 * Retrieves all direct and indirect (or direct only) subtypes of the given RelationType.
 * Specify <code>Transitive</code> for direct and indirect subtypes,
 * Or <code>Explicit</code> for directly subtypes only.
 */
struct ConceptIterator *relation_type_get_subtypes(struct Transaction *transaction,
                                                   const struct Concept *relation_type,
                                                   enum Transitivity transitivity);

/**
 * Retrieves all <code>Relation</code> objects that are instances of this <code>RelationType</code> or its subtypes.
 * Specify <code>Transitive</code> for instances of this RelationType and subtypes,
 * Or <code>Explicit</code> of this RelationType only
 */
struct ConceptIterator *relation_type_get_instances(struct Transaction *transaction,
                                                    const struct Concept *relation_type,
                                                    enum Transitivity transitivity);

/**
 * Retrieves roles that this <code>RelationType</code> relates to directly or via inheritance.
 * Specify <code>Transitive</code> for direct and inherited relates
 * Or <code>Explicit</code> for direct relates only
 */
struct ConceptIterator *relation_type_get_relates(struct Transaction *transaction,
                                                  const struct Concept *relation_type,
                                                  enum Transitivity transitivity);

/**
 * Retrieves the role with the specified label that this <code>RelationType</code> relates to, directly or via inheritance.
 */
struct ConceptPromise *relation_type_get_relates_for_role_label(struct Transaction *transaction,
                                                                const struct Concept *relation_type,
                                                                const char *role_label);

/**
 * Retrieves the <code>RoleType</code> that is overridden by the role with the <code>role_label</code>.
 */
struct ConceptPromise *relation_type_get_relates_overridden(struct Transaction *transaction,
                                                            const struct Concept *relation_type,
                                                            const char *overridden_role_label);

/**
 * Sets the new role that this <code>RelationType</code> relates to.
 * If we are setting an overriding type this way, we have to also pass overridden_role_label.
 */
struct VoidPromise *relation_type_set_relates(struct Transaction *transaction,
                                              struct Concept *relation_type,
                                              const char *role_label,
                                              const char *overridden_role_label);

/**
 * Disallows this <code>RelationType</code> from relating to the given role.
 */
struct VoidPromise *relation_type_unset_relates(struct Transaction *transaction,
                                                struct Concept *relation_type,
                                                const char *role_label);

/**
 * Retrieves the <code>ValueType</code> of this <code>AttributeType</code>.
 */
enum ValueType attribute_type_get_value_type(const struct Concept *attribute_type);

/**
 * Creates and returns a new instance of this <code>AttributeType</code>, with the specified ``Value``.
 */
struct ConceptPromise *attribute_type_put(struct Transaction *transaction,
                                          const struct Concept *attribute_type,
                                          const struct Concept *value);

/**
 * Retrieves an <code>Attribute</code> of this <code>AttributeType</code> with the given ``Value``
 * if such <code>Attribute</code> exists. Otherwise, returns <code>null</code>.
 */
struct ConceptPromise *attribute_type_get(struct Transaction *transaction,
                                          const struct Concept *attribute_type,
                                          const struct Concept *value);

/**
 * Retrieves the most immediate supertype of the given ``AttributeType``.
 */
struct ConceptPromise *attribute_type_get_supertype(struct Transaction *transaction,
                                                    const struct Concept *attribute_type);

/**
 * Sets the supplied <code>AttributeType</code> as the supertype of the current <code>AttributeType</code>.
 */
struct VoidPromise *attribute_type_set_supertype(struct Transaction *transaction,
                                                 struct Concept *attribute_type,
                                                 const struct Concept *supertype);

/**
 * Retrieves all supertypes of the given ``AttributeType``.
 */
struct ConceptIterator *attribute_type_get_supertypes(struct Transaction *transaction,
                                                      const struct Concept *attribute_type);

/**
 * Retrieves all direct and indirect (or direct only) subtypes of the given ``AttributeType``.
 * Specify <code>Transitive</code> for direct and indirect subtypes,
 * Or <code>Explicit</code> for directly subtypes only.
 */
struct ConceptIterator *attribute_type_get_subtypes(struct Transaction *transaction,
                                                    const struct Concept *attribute_type,
                                                    enum Transitivity transitivity);

/**
 * Retrieves subtypes of this <code>AttributeType</code>
 * with given <code>ValueType</code>.
 * Specify <code>Transitive</code> for direct and indirect subtypes,
 * Or <code>Explicit</code> for directly subtypes only.
 */
struct ConceptIterator *attribute_type_get_subtypes_with_value_type(struct Transaction *transaction,
                                                                    const struct Concept *attribute_type,
                                                                    enum ValueType value_type,
                                                                    enum Transitivity transitivity);

/**
 * Retrieves all <code>Attribute</code> objects that are instances of this <code>AttributeType</code> or its subtypes.
 * Specify <code>Transitive</code> for instances of this AttributeType and subtypes,
 * Or <code>Explicit</code> of this AttributeType only
 */
struct ConceptIterator *attribute_type_get_instances(struct Transaction *transaction,
                                                     const struct Concept *attribute_type,
                                                     enum Transitivity transitivity);

/**
 * Retrieves the regular expression that is defined for this <code>AttributeType</code>.
 */
struct StringPromise *attribute_type_get_regex(struct Transaction *transaction,
                                               const struct Concept *attribute_type);

/**
 * Sets a regular expression as a constraint for this <code>AttributeType</code>. <code>Value</code>s
 * of all <code>Attribute</code>s of this type (inserted earlier or later) should match this regex.
 * <p>Can only be applied for <code>AttributeType</code>s with a <code>string</code> value type.
 */
struct VoidPromise *attribute_type_set_regex(struct Transaction *transaction,
                                             const struct Concept *attribute_type,
                                             const char *regex);

/**
 * Removes the regular expression that is defined for this <code>AttributeType</code>.
 */
struct VoidPromise *attribute_type_unset_regex(struct Transaction *transaction,
                                               const struct Concept *attribute_type);

/**
 * Retrieve all <code>Things</code> that own an attribute of this <code>AttributeType</code>
 *  directly or through inheritance.
 * Specify <code>Transitive</code> for direct and inherited ownership,
 * or <code>Explicit</code> for direct ownership only
 * @param annotations a null-terminated array of <code>Annotation</code>s -
 *                    If non-empty, Only retrieves thing types of ownerships with all specified annotations.
 */
struct ConceptIterator *attribute_type_get_owners(struct Transaction *transaction,
                                                  const struct Concept *attribute_type,
                                                  enum Transitivity transitivity,
                                                  const struct Annotation *const *annotations);

/**
 * Checks if the role type is the root role type, ""relation:role""
 */
bool role_type_is_root(const struct Concept *role_type);

/**
 * Checks if the role type is prevented from having data instances (i.e., <code>abstract</code>).
 */
bool role_type_is_abstract(const struct Concept *role_type);

/**
 * Check if the role type has been deleted
 */
struct BoolPromise *role_type_is_deleted(const struct Transaction *transaction,
                                         const struct Concept *role_type);

/**
 * Retrieves the <code>RelationType</code> that this role is directly related to.
 */
struct ConceptPromise *role_type_get_relation_type(struct Transaction *transaction,
                                                   const struct Concept *role_type);

/**
 * Deletes this role type from the database.
 */
struct VoidPromise *role_type_delete(struct Transaction *transaction,
                                     const struct Concept *role_type);

/**
 * Gets the 'scope' of this role type.
 * This corresponds to the label of the <code>RelationType</code> it is directly related to.
 */
char *role_type_get_scope(const struct Concept *role_type);

/**
 * Gets the name of this role type.
 */
char *role_type_get_name(const struct Concept *role_type);

/**
 * Renames the label of the type. The new label must remain unique in the hierarchy of a relation type.
 */
struct VoidPromise *role_type_set_label(struct Transaction *transaction,
                                        const struct Concept *role_type,
                                        const char *new_label);

/**
 * Retrieves the most immediate supertype of the given ``RoleType``.
 */
struct ConceptPromise *role_type_get_supertype(struct Transaction *transaction,
                                               const struct Concept *role_type);

/**
 * Retrieves all supertypes of the given ``RoleType``.
 */
struct ConceptIterator *role_type_get_supertypes(struct Transaction *transaction,
                                                 const struct Concept *role_type);

/**
 * Retrieves all direct and indirect (or direct only) subtypes of the given ``RoleType``.
 * Specify <code>Transitive</code> for direct and indirect subtypes,
 * Or <code>Explicit</code> for directly subtypes only.
 */
struct ConceptIterator *role_type_get_subtypes(struct Transaction *transaction,
                                               const struct Concept *role_type,
                                               enum Transitivity transitivity);

/**
 * Retrieves <code>RelationType</code>s that this role is related to (directly or indirectly).
 */
struct ConceptIterator *role_type_get_relation_types(struct Transaction *transaction,
                                                     const struct Concept *role_type);

/**
 * Retrieves the <code>ThingType</code>s whose instances play this role.
 * Specify <code>Transitive</code> for direct and indirect playing,
 * or <code>Explicit</code> for direct playing only
 */
struct ConceptIterator *role_type_get_player_types(struct Transaction *transaction,
                                                   const struct Concept *role_type,
                                                   enum Transitivity transitivity);

/**
 * Retrieves the <code>Relation</code> instances that this role is related to.
 * Specify <code>Transitive</code> for direct and indirect relation,
 * or <code>Explicit</code> for direct relation only
 */
struct ConceptIterator *role_type_get_relation_instances(struct Transaction *transaction,
                                                         const struct Concept *role_type,
                                                         enum Transitivity transitivity);

/**
 * Retrieves the <code>Thing</code> instances that play this role.
 * Specify <code>Transitive</code> for direct and indirect playing,
 * or <code>Explicit</code> for direct playing only
 */
struct ConceptIterator *role_type_get_player_instances(struct Transaction *transaction,
                                                       const struct Concept *role_type,
                                                       enum Transitivity transitivity);

/**
 * Open a TypeDB Driver to a TypeDB Core server available at the provided address.
 *
 * @param address The address of the TypeDB server
 */
struct Connection *connection_open_core(const char *address);

/**
 * Open a TypeDB Driver to TypeDB Cloud server(s) available at the provided addresses, using
 * the provided credential.
 *
 * @param addresses a null-terminated array holding the address(es) of the TypeDB server(s)
 * @param credential The <code>Credential</code> to connect with
 */
struct Connection *connection_open_cloud(const char *const *addresses,
                                         const struct Credential *credential);

/**
 * Open a TypeDB Driver to TypeDB Cloud server(s), using provided address translation, with
 * the provided credential.
 *
 * @param advertised_addresses A null-terminated array holding the address(es) the TypeDB server(s)
 * are configured to advertise
 * @param translated_addresses A null-terminated array holding the address(es) of the TypeDB server(s)
 * the driver will connect to. This array <i>must</i> have the same length as <code>advertised_addresses</code>
 * @param credential The <code>Credential</code> to connect with
 */
struct Connection *connection_open_cloud_translated(const char *const *advertised_addresses,
                                                    const char *const *translated_addresses,
                                                    const struct Credential *credential);

/**
 * Closes the driver. Before instantiating a new driver, the driver that’s currently open should first be closed.
 * Closing a connction frees the underlying rust object.
 */
void connection_close(struct Connection *connection);

/**
 * Checks whether this connection is presently open.
 */
bool connection_is_open(const struct Connection *connection);

/**
 * Forcibly closes the driver. To be used in exceptional cases.
 */
void connection_force_close(struct Connection *connection);

/**
 * Creates a new <code>Credential</code> for connecting to TypeDB Cloud.
 *
 * @param username The name of the user to connect as
 * @param password The password for the user
 * @param tls_root_ca Path to the CA certificate to use for authenticating server certificates.
 * @param with_tls Specify whether the connection to TypeDB Cloud must be done over TLS
 */
struct Credential *credential_new(const char *username,
                                  const char *password,
                                  const char *tls_root_ca,
                                  bool with_tls);

/**
 * Frees the native rust <code>Credential</code> object
 */
void credential_drop(struct Credential *credential);

/**
 * Frees the native rust <code>Database</code> object
 */
void database_close(struct Database *database);

/**
 * The database name as a string.
 */
char *database_get_name(const struct Database *database);

/**
 * Deletes this database.
 */
void database_delete(struct Database *database);

/**
 * A full schema text as a valid TypeQL define query string.
 */
char *database_schema(struct Database *database);

/**
 * The types in the schema as a valid TypeQL define query string.
 */
char *database_type_schema(struct Database *database);

/**
 * The rules in the schema as a valid TypeQL define query string.
 */
char *database_rule_schema(struct Database *database);

/**
 * Forwards the <code>ReplicaInfoIterator</code> and returns the next <code>ReplicaInfo</code> if it exists,
 * or null if there are no more elements.
 */
struct ReplicaInfo *replica_info_iterator_next(struct ReplicaInfoIterator *it);

/**
 * Frees the native rust <code>ReplicaInfoIterator</code> object
 */
void replica_info_iterator_drop(struct ReplicaInfoIterator *it);

/**
 * Set of <code>Replica</code> instances for this database.
 * <b>Only works in TypeDB Cloud</b>
 */
struct ReplicaInfoIterator *database_get_replicas_info(const struct Database *database);

/**
 * Returns the primary replica for this database.
 * _Only works in TypeDB Cloud_
 */
struct ReplicaInfo *database_get_primary_replica_info(const struct Database *database);

/**
 * Returns the preferred replica for this database.
 * Operations which can be run on any replica will prefer to use this replica.
 * _Only works in TypeDB Cloud_
 */
struct ReplicaInfo *database_get_preferred_replica_info(const struct Database *database);

/**
 * Frees the native rust <code>ReplicaInfo</code> object
 */
void replica_info_drop(struct ReplicaInfo *replica_info);

/**
 * The server hosting this replica
 */
char *replica_info_get_server(const struct ReplicaInfo *replica_info);

/**
 * Checks whether this is the primary replica of the raft cluster.
 */
bool replica_info_is_primary(const struct ReplicaInfo *replica_info);

/**
 * Checks whether this is the preferred replica of the raft cluster.
 * If true, Operations which can be run on any replica will prefer to use this replica.
 */
bool replica_info_is_preferred(const struct ReplicaInfo *replica_info);

/**
 * The raft protocol ‘term’ of this replica.
 */
int64_t replica_info_get_term(const struct ReplicaInfo *replica_info);

/**
 * Creates and returns a native <code>DatabaseManager</code> for the connection
 */
struct DatabaseManager *database_manager_new(const struct Connection *connection);

/**
 * Frees the native rust <code>DatabaseManager</code> object
 */
void database_manager_drop(struct DatabaseManager *databases);

/**
 * Forwards the <code>DatabaseIterator</code> and returns the next <code>Database</code> if it exists,
 * or null if there are no more elements.
 */
struct Database *database_iterator_next(struct DatabaseIterator *it);

/**
 * Frees the native rust <code>DatabaseIterator</code> object
 */
void database_iterator_drop(struct DatabaseIterator *it);

/**
 * Returns a <code>DatabaseIterator</code> over all databases present on the TypeDB server
 */
struct DatabaseIterator *databases_all(struct DatabaseManager *databases);

/**
 * Create a database with the given name
 */
void databases_create(struct DatabaseManager *databases, const char *name);

/**
 * Checks if a database with the given name exists
 */
bool databases_contains(struct DatabaseManager *databases, const char *name);

/**
 * Retrieve the database with the given name.
 */
struct Database *databases_get(struct DatabaseManager *databases, const char *name);

/**
 * Enables logging in the TypeDB driver.
 */
void init_logging(void);

/**
 * Checks if the error flag was set by the last operation.
 * If true, the error can be retrieved using \ref get_last_error(void)
 */
bool check_error(void);

/**
 * Returns the error which set the error flag.
 */
struct Error *get_last_error(void);

/**
 * Frees the native rust <code>Error</code> object
 */
void error_drop(struct Error *error);

/**
 * Returns the error code of the <code>Error</code> object
 */
char *error_code(const struct Error *error);

/**
 * Returns the error message of the <code>Error</code> object
 */
char *error_message(const struct Error *error);

/**
 * Frees the native rust <code>ReplicaInfoIterator</code> object.
 */
void rule_drop(struct Rule *rule);

/**
 * A string representation of this <code>Rule</code> object
 */
char *rule_to_string(const struct Rule *rule);

/**
 * Retrieves the unique label of the rule.
 */
char *rule_get_label(const struct Rule *rule);

/**
 * The statements that constitute the ‘when’ of the rule.
 */
char *rule_get_when(const struct Rule *rule);

/**
 * The single statement that constitutes the ‘then’ of the rule.
 */
char *rule_get_then(const struct Rule *rule);

/**
 * Renames the label of the rule. The new label must remain unique.
 */
struct VoidPromise *rule_set_label(const struct Transaction *transaction,
                                   struct Rule *rule,
                                   const char *new_label);

/**
 * Deletes this rule.
 */
struct VoidPromise *rule_delete(const struct Transaction *transaction, struct Rule *rule);

/**
 * Check if this rule has been deleted.
 */
struct BoolPromise *rule_is_deleted(const struct Transaction *transaction, struct Rule *rule);

/**
 * Waits for and returns the result of the operation represented by the <code>RulePromise</code> object.
 * In case the operation failed, the error flag will only be set when the promise is resolved.
 * The native promise object is freed when it is resolved.
 */
struct Rule *rule_promise_resolve(struct RulePromise *promise);

/**
 * Creates a new Rule if none exists with the given label, or replaces the existing one.
 *
 * @param label The label of the Rule to create or replace
 *  @param when The when body of the rule to create
 *  @param then The then body of the rule to create
 */
struct RulePromise *logic_manager_put_rule(struct Transaction *transaction,
                                           const char *label,
                                           const char *when,
                                           const char *then);

/**
 * Retrieves the Rule that has the given label.
 */
struct RulePromise *logic_manager_get_rule(struct Transaction *transaction, const char *label);

/**
 * Forwards the <code>RuleIterator</code> and returns the next <code>Rule</code> if it exists,
 * or null if there are no more elements.
 */
struct Rule *rule_iterator_next(struct RuleIterator *it);

/**
 * Frees the native rust <code>RuleIterator</code> object.
 */
void rule_iterator_drop(struct RuleIterator *it);

/**
 * Returns a <code>RuleIterator</code> over all rules in the database for the transaction.
 */
struct RuleIterator *logic_manager_get_rules(struct Transaction *transaction);

/**
 * Frees a native rust string.
 * _WARNING: Always use this function to free strings returned by the driver. Using the standard C free function will create a dangling reference on the rust side._
 */
void string_free(char *str);

/**
 * Produces a new <code>TypeDBOptions</code> object.
 */
struct Options *options_new(void);

/**
 * Frees the native rust <code>Options</code> object.
 */
void options_drop(struct Options *options);

/**
 * Explicitly enables or disables inference.
 * Only settable at transaction level and above. Only affects read transactions.
 */
void options_set_infer(struct Options *options, bool infer);

/**
 * Explicitly enables or disables reasoning tracing.
 * If set to <code>true</code>, reasoning tracing graphs are output in the logging directory.
 * Should be used with <code>parallel = False</code>.
 */
void options_set_trace_inference(struct Options *options, bool trace_inference);

/**
 * Explicitly enables or disables explanations.
 * If set to <code>true</code>, enables explanations for queries. Only affects read transactions.
 */
void options_set_explain(struct Options *options, bool explain);

/**
 * Explicitly enables or disables parallel execution.
 * If set to <code>true</code>, the server uses parallel instead of single-threaded execution.
 */
void options_set_parallel(struct Options *options, bool parallel);

/**
 * Explicitly enables or disables prefetching.
 * If set to <code>true</code>, the first batch of answers is streamed to the driver even without
 * an explicit request for it.
 */
void options_set_prefetch(struct Options *options, bool prefetch);

/**
 * Explicitly sets a prefetch size.
 * If set, specifies a guideline number of answers that the server should send before the driver
 * issues a fresh request.
 *
 * @param prefetchSize Number of answers that the server should send before the driver issues a fresh request
 */
void options_set_prefetch_size(struct Options *options,
                               int32_t prefetch_size);

/**
 * Explicitly sets a session idle timeout.
 * If set, specifies a timeout that allows the server to close sessions if the driver terminates
 * or becomes unresponsive.
 */
void options_set_session_idle_timeout_millis(struct Options *options, int64_t timeout_millis);

/**
 * Explicitly set a transaction timeout.
 * If set, specifies a timeout for killing transactions automatically, preventing memory leaks
 * in unclosed transactions.
 */
void options_set_transaction_timeout_millis(struct Options *options, int64_t timeout_millis);

/**
 * Explicitly sets schema lock acquire timeout.
 * If set, specifies how long the driver should wait if opening a session or transaction is blocked
 * by a schema write lock.
 */
void options_set_schema_lock_acquire_timeout_millis(struct Options *options,
                                                    int64_t timeout_millis);

/**
 * Explicitly enables or disables reading data from any replica.
 * If set to <code>True</code>, enables reading data from any replica, potentially boosting read throughput.
 * Only settable in TypeDB Cloud.
 */
void options_set_read_any_replica(struct Options *options,
                                  bool read_any_replica);

/**
 * Returns the value set for the inference in this <code>TypeDBOptions</code> object.
 */
bool options_get_infer(const struct Options *options);

/**
 * Returns the value set for reasoning tracing in this <code>TypeDBOptions</code> object.
 * If set to <code>true</code>, reasoning tracing graphs are output in the logging directory.
 */
bool options_get_trace_inference(const struct Options *options);

/**
 *Returns the value set for the explanation in this <code>TypeDBOptions</code> object.
 * If set to <code>true</code>, explanations for queries are enabled.
 */
bool options_get_explain(const struct Options *options);

/**
 * Returns the value set for the parallel execution in this <code>TypeDBOptions</code> object.
 * If set to <code>true</code>, the server uses parallel instead of single-threaded execution.
 */
bool options_get_parallel(const struct Options *options);

/**
 * Returns the value set for the prefetching in this <code>TypeDBOptions</code> object.
 * If set to <code>true</code>, the first batch of answers is streamed to the driver even without
 * an explicit request for it.
 */
bool options_get_prefetch(const struct Options *options);

/**
 * Returns the value set for the prefetch size in this <code>TypeDBOptions</code> object.
 * If set, specifies a guideline number of answers that the server should send before the driver
 * issues a fresh request.
 */
int32_t options_get_prefetch_size(const struct Options *options);

/**
 * Returns the value set for the session idle timeout in this <code>TypeDBOptions</code> object.
 * If set, specifies a timeout that allows the server to close sessions if the driver terminates
 * or becomes unresponsive.
 */
int64_t options_get_session_idle_timeout_millis(const struct Options *options);

/**
 * Returns the value set for the transaction timeout in this <code>TypeDBOptions</code> object.
 * If set, specifies a timeout for killing transactions automatically, preventing memory leaks
 * in unclosed transactions.
 */
int64_t options_get_transaction_timeout_millis(const struct Options *options);

/**
 * Returns the value set for the schema lock acquire timeout in this <code>TypeDBOptions</code> object.
 * If set, specifies how long the driver should wait if opening a session or transaction is blocked
 * by a schema write lock.
 */
int64_t options_get_schema_lock_acquire_timeout_millis(const struct Options *options);

/**
 * Returns the value set for reading data from any replica in this <code>TypeDBOptions</code> object.
 * If set to <code>True</code>, enables reading data from any replica, potentially boosting read throughput.
 */
bool options_get_read_any_replica(const struct Options *options);

/**
 * Checks whether the option for inference was explicitly set for this <code>TypeDBOptions</code> object.
 */
bool options_has_infer(const struct Options *options);

/**
 * Checks whether the option for reasoning tracing was explicitly set for this <code>TypeDBOptions</code> object.
 */
bool options_has_trace_inference(const struct Options *options);

/**
 * Checks whether the option for explanation was explicitly set for this <code>TypeDBOptions</code> object.
 */
bool options_has_explain(const struct Options *options);

/**
 * Checks whether the option for parallel execution was explicitly set for this <code>TypeDBOptions</code> object.
 */
bool options_has_parallel(const struct Options *options);

/**
 * Checks whether the option for prefetching was explicitly set for this <code>TypeDBOptions</code> object.
 */
bool options_has_prefetch(const struct Options *options);

/**
 * Checks whether the option for prefetch size was explicitly set for this <code>TypeDBOptions</code> object.
 */
bool options_has_prefetch_size(const struct Options *options);

/**
 * Checks whether the option for the session idle timeout was explicitly set for this <code>TypeDBOptions</code> object.
 */
bool options_has_session_idle_timeout_millis(const struct Options *options);

/**
 * Checks whether the option for transaction timeout was explicitly set for this <code>TypeDBOptions</code> object.
 */
bool options_has_transaction_timeout_millis(const struct Options *options);

/**
 * Checks whether the option for schema lock acquire timeout was explicitly set for this <code>TypeDBOptions</code> object.
 */
bool options_has_schema_lock_acquire_timeout_millis(const struct Options *options);

/**
 * Checks whether the option for reading data from any replica was explicitly set for this <code>TypeDBOptions</code> object.
 */
bool options_has_read_any_replica(const struct Options *options);

/**
 * Waits for the operation represented by the <code>VoidPromise</code> to complete.
 * In case the operation failed, the error flag will only be set when the promise is resolved.
 * The native promise object is freed when it is resolved.
 */
void void_promise_resolve(struct VoidPromise *promise);

/**
 * Waits for and returns the result of the operation represented by the <code>BoolPromise</code> object.
 * In case the operation failed, the error flag will only be set when the promise is resolved.
 * The native promise object is freed when it is resolved.
 */
bool bool_promise_resolve(struct BoolPromise *promise);

/**
 * Waits for and returns the result of the operation represented by the <code>BoolPromise</code> object.
 * In case the operation failed, the error flag will only be set when the promise is resolved.
 * The native promise object is freed when it is resolved.
 */
char *string_promise_resolve(struct StringPromise *promise);

/**
 * Performs a TypeQL Define query in the transaction.
 */
struct VoidPromise *query_define(struct Transaction *transaction,
                                 const char *query,
                                 const struct Options *options);

/**
 * Performs a TypeQL Undefine query in the transaction.
 */
struct VoidPromise *query_undefine(struct Transaction *transaction,
                                   const char *query,
                                   const struct Options *options);

/**
 * Performs a TypeQL Delete query in the transaction.
 */
struct VoidPromise *query_delete(struct Transaction *transaction,
                                 const char *query,
                                 const struct Options *options);

/**
 * Forwards the <code>ConceptMapIterator</code> and returns the next <code>ConceptMap</code> if it exists,
 * or null if there are no more elements.
 */
struct ConceptMap *concept_map_iterator_next(struct ConceptMapIterator *it);

/**
 * Frees the native rust <code>ConceptMapIterator</code> object
 */
void concept_map_iterator_drop(struct ConceptMapIterator *it);

/**
 * Performs a TypeQL Get (Get) query in the transaction.
 */
struct ConceptMapIterator *query_get(struct Transaction *transaction,
                                     const char *query,
                                     const struct Options *options);

/**
 * Performs a TypeQL Fetch query in the transaction.
 */
struct StringIterator *query_fetch(struct Transaction *transaction,
                                   const char *query,
                                   const struct Options *options);

/**
 * Performs a TypeQL Insert query in the transaction.
 */
struct ConceptMapIterator *query_insert(struct Transaction *transaction,
                                        const char *query,
                                        const struct Options *options);

/**
 * Performs a TypeQL Update query in the transaction.
 */
struct ConceptMapIterator *query_update(struct Transaction *transaction,
                                        const char *query,
                                        const struct Options *options);

/**
 * Performs a TypeQL Get Aggregate query in the transaction.
 */
struct ConceptPromise *query_get_aggregate(struct Transaction *transaction,
                                           const char *query,
                                           const struct Options *options);

/**
 * Forwards the <code>ConceptMapGroupIterator</code> and returns the next <code>ConceptMapGroup</code> if it exists,
 * or null if there are no more elements.
 */
struct ConceptMapGroup *concept_map_group_iterator_next(struct ConceptMapGroupIterator *it);

/**
 * Frees the native rust <code>ConceptMapGroupIterator</code> object
 */
void concept_map_group_iterator_drop(struct ConceptMapGroupIterator *it);

/**
 * Performs a TypeQL Get Group query in the transaction.
 */
struct ConceptMapGroupIterator *query_get_group(struct Transaction *transaction,
                                                const char *query,
                                                const struct Options *options);

/**
 * Forwards the <code>ValueGroupIterator</code> and returns the next <code>ValueGroup</code> if it exists,
 * or null if there are no more elements.
 */
struct ValueGroup *value_group_iterator_next(struct ValueGroupIterator *it);

/**
 * Frees the native rust <code>ValueGroupIterator</code> object
 */
void value_group_iterator_drop(struct ValueGroupIterator *it);

/**
 * Performs a TypeQL Get Group Aggregate query in the transaction.
 */
struct ValueGroupIterator *query_get_group_aggregate(struct Transaction *transaction,
                                                     const char *query,
                                                     const struct Options *options);

/**
 * Forwards the <code>Explanation</code> and returns the next <code>Explanation</code> if it exists,
 * or null if there are no more elements.
 */
struct Explanation *explanation_iterator_next(struct ExplanationIterator *it);

/**
 * Frees the native rust <code>ExplanationIterator</code> object
 */
void explanation_iterator_drop(struct ExplanationIterator *it);

/**
 * Performs a TypeQL Explain query in the transaction.
 * @param explainable The Explainable to be explained
 *  @param options Specify query options
 */
struct ExplanationIterator *query_explain(struct Transaction *transaction,
                                          const struct Explainable *explainable,
                                          const struct Options *options);

/**
 * Opens a session to the given database.
 *
 * @param databases The <code>DatabaseManager</code> object on this connection.
 * @param database_name The name of the database with which the session connects
 * @param session_type The type of session to be created (Schema or Data)
 * @param options <code>Options</code> for this session
 */
struct Session *session_new(struct DatabaseManager *databases,
                            const char *database_name,
                            enum SessionType session_type,
                            const struct Options *options);

/**
 * Closes the session. Before opening a new session, the session currently open should first be closed.
 * The native rust object is freed on close.
 */
void session_close(struct Session *session);

/**
 * Returns the name of the database of the session.
 */
char *session_get_database_name(const struct Session *session);

/**
 * Checks whether this session is open.
 */
bool session_is_open(const struct Session *session);

/**
 * Forcibly closes the session. To be used in exceptional cases.
 */
void session_force_close(struct Session *session);

/**
 * Registers a callback function which will be executed when this session is closed.
 *
 * @param session The session on which to register the callback
 * @param data The argument to be passed to the callback function when it is executed
 * @param callback The function to be called
 * @param finished A function which will be executed when the session is destroyed, allowing cleanup
 */
void session_on_close(const struct Session *session,
                      void *data,
                      void (*callback)(void*),
                      void (*finished)(void*));

/**
 * Registers a callback function which will be executed when this session is reopened.
 * A session may be closed if it times out, or loses the connection to the database.
 * In such situations, the session is reopened automatically when opening a new transaction.
 *
 * @param session The session on which to register the callback
 * @param data The argument to be passed to the callback function when it is executed
 * @param callback The function to be called
 * @param finished A function which will be executed when the session is destroyed, allowing cleanup
 */
void session_on_reopen(const struct Session *session,
                       void *data,
                       void (*callback)(void*),
                       void (*finished)(void*));

/**
 * Opens a transaction to perform read or write queries on the database connected to the session.
 *
 * @param type_ The type of transaction to be created (Write or Read).
 * @param options Options for the transaction
 */
struct Transaction *transaction_new(const struct Session *session,
                                    enum TransactionType type_,
                                    const struct Options *options);

/**
 * Closes the transaction and frees the native rust object.
 */
void transaction_close(struct Transaction *txn);

/**
 * Forcibly closes this transaction. To be used in exceptional cases.
 */
void transaction_force_close(struct Transaction *txn);

/**
 * Commits the changes made via this transaction to the TypeDB database.
 * Whether or not the transaction is commited successfully, the transaction is closed after
 * the commit call and the native rust object is freed.
 */
struct VoidPromise *transaction_commit(struct Transaction *txn);

/**
 * Rolls back the uncommitted changes made via this transaction.
 */
struct VoidPromise *transaction_rollback(const struct Transaction *txn);

/**
 * Checks whether this transaction is open.
 */
bool transaction_is_open(const struct Transaction *txn);

/**
 * Registers a callback function which will be executed when this transaction is closed.
 *
 * @param txn The transaction on which to register the callback
 * @param callback_id The argument to be passed to the callback function when it is executed.
 * @param callback The function to be called
 */
void transaction_on_close(const struct Transaction *txn,
                          uintptr_t callback_id,
                          void (*callback)(uintptr_t, struct Error*));

/**
 * Frees the native rust <code>User</code> object.
 */
void user_drop(struct User *user);

/**
 * Returns the name of this user.
 */
char *user_get_username(struct User *user);

/**
 * Returns the number of seconds remaining till this user’s current password expires.
 */
int64_t user_get_password_expiry_seconds(struct User *user);

/**
 * Updates the password for the current authenticated user.
 *
 * @param user The user to update the password of - must be the current user.
 * @param user_manager The <code>UserManager</code> object on this connection.
 * @param password_old The current password of this user
 * @param password_new The new password
 */
void user_password_update(struct User *user,
                          const struct UserManager *user_manager,
                          const char *password_old,
                          const char *password_new);

/**
 * Creates a <code>UserManager</code> on the specified connection
 */
struct UserManager *user_manager_new(const struct Connection *connection);

/**
 * Frees the native rust <code>UserManager</code> object
 */
void user_manager_drop(struct UserManager *user_manager);

/**
 * Retrieves the user who opened this connection
 */
struct User *users_current_user(const struct UserManager *user_manager);

/**
 * Forwards the <code>UserIterator</code> and returns the next <code>User</code> if it exists,
 * or null if there are no more elements.
 */
struct User *user_iterator_next(struct UserIterator *it);

/**
 * Frees the native rust <code>UserIterator</code> object
 */
void user_iterator_drop(struct UserIterator *it);

/**
 * Retrieves all users which exist on the TypeDB server.
 */
struct UserIterator *users_all(const struct UserManager *user_manager);

/**
 * Checks if a user with the given name exists.
 */
bool users_contains(const struct UserManager *user_manager, const char *username);

/**
 * Creates a user with the given name &amp; password.
 */
void users_create(const struct UserManager *user_manager,
                  const char *username,
                  const char *password);

/**
 * Deletes the user with the given username.
 */
void users_delete(const struct UserManager *user_manager, const char *username);

/**
 * Retrieves a user with the given name.
 */
struct User *users_get(const struct UserManager *user_manager, const char *username);

/**
 * Sets a new password for a user. This operation can only be performed by administrators.
 *
 * @param user_manager The </code>UserManager</code> object to be used.
 *                     This must be on a connection opened by an administrator.
 * @param username The name of the user to set the password of
 * @param password The new password
 */
void users_set_password(const struct UserManager *user_manager,
                        const char *username,
                        const char *password);

/** @file */ // Tells doxygen to document this file.
